---
layout:     post
title:      「刷题笔记」双指针法（快慢指针法）
subtitle:   基于Pytorch平台
date:       2021-10-09
author:     WJ
header-img: img/post-bg-hacker.png
catalog: false
tags:
    - 刷题笔记
---

# 一、顺序结构中的双指针法

顺序结构：这里主要指的是数组或字符串。

### （1）普通数组

slow指向   当前所需元素数组的下一个空位。返回值为slow时，slow就代表目标数组的长度。

| **题目简述**                       | **关键点**                   | **解题思路**                                                 | **力扣题目**            |                   **相关链接**                   |
| ---------------------------------- | ---------------------------- | ------------------------------------------------------------ | ----------------------- | :----------------------------------------------: |
| 删除数组中的某类元素               | 同向移动，快慢指针同时出发； | slow：指向当前所需元素数组的下一个空位。fast：遍历数组。     如果快指针遇到目标值则快指针直接跳过它一步，慢指针不动，**如果快指针没有遇到目标值则将自己手中的数交给慢指针**，然后各自前进一步。 | 27 移除元素（简单难度） | https://leetcode-cn.com/problems/remove-element/ |
| 移动数组中的某类元素到开头或者末尾 | 同向移动，快慢指针同时出发； | 如果快指针遇到目标值则快指针直接跳过它一步，慢指针不动，如果快指针没有遇到目标值则将自己手中的数和慢指针交换，然后各自前进一步。 | 283 移动零（简单难度）  |  https://leetcode-cn.com/problems/move-zeroes/   |

### （2）有序数组

无序数组可以直接使用sort()函数排序后变成有序数组。sort(nums.begin(),nums.end())



| **题目简述**                       | **关键点**                                                   | **解题思路**                                                 | **力扣题目**                          | **相关链接**                                                 |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------- | ------------------------------------------------------------ |
| 删除**有序数组**中的重复元素       | 同向移动，快指针先行一步，每次不断比较两个指针上的数是否相同。 | **一个指针（fast）从头到尾遍历，另一个（slow）始终指示当前没有重复的元素数组的下一个空位置；**相同则快指针直接跳过去多行一步，不相同则快指针将手中的数交给慢指针，然后快慢指针同时前进一步；（这时慢指针指的是当前没有重复元素的最后一个*：注意返回值是slow+1。） | 26 删除排序数组中的重复项（简单难度） | https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ |
| 求有序数组中的众数（可能不止一个） | 同向移动，快指针先行一步，每次不断比较两个指针上的数是否相同。 | 相同则频率计时器+1，不相同则频率计时器设为0；每次检查频率计时器是否超过最大计数，超过则记录当前快指针上的数为众数。vector数组排序：sort(nums.begin(),nums.end()) | **169 多数元素（中等难度）**          | https://leetcode-cn.com/problems/majority-element/           |
| 将有序数组中每个元素平方后再排序   | 反向移动，左指针和右指针同时出发，每次比较左指针和右指针手上的数的平方； | 如果左指针手中数的平方更大则移动起始指针，如果末尾指针手中的数更大则移动末尾指针；当起始指针大于末尾指针时循环结束。（有序数组平方数组平方的最大值就在数组的两端，所以排序需要不断比较数组两端的数） | 977 有序数组的平方（简单难度）        | https://leetcode-cn.com/problems/squares-of-a-sorted-array/  |

#### 169 多数元素（中等难度）

#### 1、排序法

​       **众数是指在数组中出现次数大于`⌊ n/2 ⌋` 的元素**。 先将nums排序， ，然后返回中间元素的值即可（众数的个数大于一半，排好序的`nums`中间元素一定是众数） 。

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums[nums.size()/2];
    }
};
```

#### 2、摩尔投票法思路

候选人(cand_num)初始化为nums[0]，票数count初始化为1。
当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。
当票数count为0时，更换候选人，并将票数count重置为1。
遍历完数组后，cand_num即为最终答案。

为何这行得通呢？
投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。
且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。
因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。
这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。

无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。

作者：gfu
链接：https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2/
来源：力扣（LeetCode）

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cand=nums[0],count=1;
        for(int i=1;i<nums.size();i++){
            if(cand==nums[i]){
                count++;
            }
            else if(--count==0){
                cand=nums[i];
                count=1;
            }
        }
        return cand;
    }
};
```

