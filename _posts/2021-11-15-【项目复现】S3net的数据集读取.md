---

layout:     post
title:      「项目复现」S3net的数据集读取
subtitle:   CVPRW 2021
date:       2021-11-15
author:     WJ
header-img: img/post-bg-hacker.png
catalog: true
tags:
    - 项目复现
---

​		本博客是作者复现《S3Net: A Single Stream Structure for Depth Guided Image Relighting》的数据集读取代码的笔记。



函数：测试 加载**训练数据集**的函数

```c++
def test_trainSet():
    # 创建数据集
    origin_img_path = '../datasets/alltrain/*.png'# 输入的原始图像的路径
    guide_img_path = origin_img_path # 引导图像路径
    dataset = trainDataSetFromTrack2(origin_img_path, guide_img_path,10)# 根据图片路径读取数据集
    trainloader = DataLoader(dataset, batch_size=1, shuffle=True, num_workers=0)
    # 输出信息
    print("训练集一共有{}/{}={}个的批次,其中{}是mini-batch".format(len(dataset), 1, len(trainloader), 1))
    batchdict = next(iter(trainloader))# 得到一组样本数据
    ori_image, guide_image, ori_depth, guide_depth = batchdict['x']
    img_name = batchdict['img_name']
    print(ori_image.shape)
    print(guide_image.shape)
    print(ori_depth.shape)
    print(guide_depth.shape)
    print('img_name', img_name)
    save_img(ori_image,'./1.png')
```

**加载训练数据集的函数**

```c++
# 自定义训练数据集
class trainDataSetFromTrack2(Dataset):
    def __init__(self,
                 origin_img_path: str,  # 输入文件所在的路径
                 guide_img_path: str,  # 输出文件所在的路径
                 num:int,# 读取的图片数量
                 ):
        super(trainDataSetFromTrack2, self).__init__()
        # 获取所有图片的路径
        self.origin_img_paths, self.guide_img_paths = self._get_dataset_path(origin_img_path, guide_img_path)
        self.len = len(self.origin_img_paths)
        # 选取指定数量的图片
        if num > 0 and num < self.len:
            self.origin_img_paths = self.origin_img_paths[:num]
            self.guide_img_paths =self.guide_img_paths[:num]
            self.len = num
        # 获取图像预处理函数
        self.preprocess_fn = data_transform
        print(f'含有{self.len} 个样本的数据集已被创建')

    # 获取一组图片数据
    def __getitem__(self, index):
        # 获取一组样本的路径
        origin_img_path, guide_img_path = self.origin_img_paths[index % self.len], self.guide_img_paths[index % self.len]
        origin_depth_name = origin_img_path.split('_')[0]+'.npy'  # 拼接出原始图像对应深度图的路径：Image000+.npy
        guide_depth_name = guide_img_path.split('_')[0]+'.npy' # 拼接出指导图像对应深度图的路径: Image001+.npy
        truth_img_name = origin_img_path.split('_')[0]+'_'+guide_img_path.split('_')[1]+'_'+guide_img_path.split('_')[2]# 拼接出真实图像的路径：原始图像的前缀Image000+指导图像的后缀
        # 读取该组样本的RGB图片
        ori_image, guide_image,truth_img = map(self._read_rgb_img, (origin_img_path, guide_img_path,truth_img_name))

        # 读取该组样本的depth图片
        ori_depth, guide_depth = map(self._read_depth_img, (origin_depth_name, guide_depth_name))
        # 获取该组样本对应的名称
        img_name = origin_img_path.split('\\')[1]
        return {'x':(ori_image, guide_image, ori_depth, guide_depth),
                'y':truth_img,
                'img_name':img_name}

    def __len__(self):
        return self.len

    def _read_rgb_img(self,img_path):
        img = Image.open(str(img_path))  # （1024,1024,4）
        # image_tensor = self.preprocess_fn(img).unsqueeze(0)  # tensor，size=（1,4,1024,1024）
        # image_tensor = image_tensor[:, :3, :, :]  # tensor，size=（1,3,1024,1024）
        image_tensor = self.preprocess_fn(img)  # tensor，size=（4,1024,1024）
        image_tensor = image_tensor[:3, :, :]  # tensor，size=（3,1024,1024）
        return image_tensor

    def _read_depth_img(self,depth_path):
        depth = np.load(depth_path, allow_pickle=True).item()['normalized_depth']
        ori_depth = torch.unsqueeze(torch.from_numpy(depth), 0)  # 升维(1,1024,1024)
        #ori_depth = torch.unsqueeze(ori_depth, 0)  # 升维(1,1,1024,1024)
        return ori_depth



    # 获取样本文件的所有路径
    def _get_dataset_path(self, input_file_path, target_file_path):
        origin_img_paths = sorted(glob.glob(input_file_path, recursive=True))
        guide_img_paths = glob.glob(target_file_path, recursive=True)
        random.shuffle(guide_img_paths)
        #assert len(origin_img_paths) == len(guide_img_paths)
        return origin_img_paths, guide_img_paths
```



