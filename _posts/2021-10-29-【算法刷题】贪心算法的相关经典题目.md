---

layout:     post
title:      「算法刷题」贪心算法的相关经典题目
subtitle:   基于C++语言
date:       2021-10-29
author:     WJ
header-img: img/post-bg-hacker.png
catalog: false
tags:
    - 算法刷题
---



| **LeetCode题目** | **相关题目类型**     | **相关链接**                                                 |
| ---------------- | -------------------- | ------------------------------------------------------------ |
| 455              | 分发饼干（简单难度） | [383. 赎金信 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ransom-note/) |

为了了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。

然后从后向前遍历小孩数组，用大饼干优先满足 

![image-20211029212703299](C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211029212703299.png)

这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。

```c++
// 时间复杂度：O(nlogn)
// 空间复杂度：O(1)
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size() - 1; // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) {
            if (index >= 0 && s[index] >= g[i]) {
                result++;
                index--;
            }
        }
        return result;
    }
};
```

从代码中可以看出我用了一个index来控制饼干数组的遍历，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。

有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。

**也可以换一个思路，小饼干先喂饱小胃口**

代码如下：

```CPP
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index = 0;
        for(int i = 0;i < s.size();++i){
            if(index < g.size() && g[index] <= s[i]){
                index++;
            }
        }
        return index;
    }
};
```



| **LeetCode题目** | **相关题目类型**                    | **相关链接**                                                 |
| ---------------- | ----------------------------------- | ------------------------------------------------------------ |
| 1005             | K次取反后最大化的数组和（简单难度） | [1005. K 次取反后最大化的数组和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/) |



本题思路其实比较好想了，如何可以让数组和最大呢？

贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。

局部最优可以推出全局最优。

那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。

那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。

虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。

**我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！**

那么本题的解题步骤为：

* 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
* 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
* 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
* 第四步：求和

对应C++代码如下：

```
class Solution {
static bool cmp(int a,int b){
    return abs(a)>abs(b);
}

public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        //将数组按照绝对值大小，从大到小排列
        sort(A.begin(),A.end(),cmp);
        //如果数组中有负数，转为正数，同时k--
        for(int i=0;i<A.size()-1;i++){
            if(A[i]<0&&K>0){
                A[i]*=-1;
                K--;

            }
        }
        //如果k不为0，把数组中最小的数反复乘以-1，直到k用完
        //K%2==0的话，数组中的数还是原数
        if(K%2==1){
            A[A.size()-1]*=-1;
        }
        //求和
        int res=0;
        for(int a:A){
            res+=a;
        }
        return res;
        
    }
};
```

