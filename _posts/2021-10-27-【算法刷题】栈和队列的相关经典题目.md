---

layout:     post
title:      「算法刷题」栈和队列的相关经典题目
subtitle:   基于C++语言
date:       2021-10-27
author:     WJ
header-img: img/post-bg-hacker.png
catalog: false
tags:
    - 算法刷题
---

一、栈的定义：

​    一种可以实现“先进后出（后进先出）”的存储结构

s.empty();         //如果栈为空则返回true, 否则返回false;
s.size();          //返回栈中元素的个数
s.top();           //返回栈顶元素, 但不删除该元素
s.pop();           //弹出/删除栈顶元素, 但不返回其值
s.push();          //将元素压入栈顶

 在压栈的过程中，栈顶的位置一直在”向上“移动，而栈底是固定不变的。 

![image-20211027221030901](C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211027221030901.png)

 如果我们要把栈中的元素弹出来： 先入后出

![image-20211027221100703](C:\Users\WJ\AppData\Roaming\Typora\typora-user-images\image-20211027221100703.png)

# 

| **LeetCode题目** | **相关题目类型**         | **相关链接**                                                 |
| ---------------- | ------------------------ | ------------------------------------------------------------ |
| 232              | 用栈实现队列（简单难度） | [232. 用栈实现队列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-queue-using-stacks/) |

在push数据的时候，只要数据放进输入栈就好，**但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）**，再从出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据就可以了。

最后如何判断队列为空呢？**如果进栈和出栈都为空的话，说明模拟的队列为空了。**

在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。



输入栈的元素出栈再放到输出栈中，这样输出栈的输出顺序和队列顺序一样了（手画一下）

```c++
class MyQueue {
public:
    stack<int>sck1;
    stack<int>sck2;
    MyQueue() {

    }
    
    void push(int x) {
        sck1.push(x);
        return ;
    }
    
    int pop() {
        // 把输入栈sck1中的元素放到输出栈sck2，清空sck1
        // 这样stk2的出栈顺序和输入的元素入stk1的顺序是一样的了
        while(!sck1.empty()){
            int num=sck1.top();// 获取栈顶元素，但不删除
            sck1.pop();// 删除栈顶元素，但不返回
            sck2.push(num); // 将元素压入栈顶
        }

        int val=sck2.top();// 返回栈顶元素
        sck2.pop();// 删除栈顶元素
        // 清空输出栈sck2
        while(!sck2.empty()){
            sck1.push(sck2.top());
            sck2.pop();
        }
        return val;
    }
    // 返回队列开头的元素
    int peek() {
        // 清空sck1，元素放入到sck2
        while(!sck1.empty()){
            sck2.push(sck1.top());
            sck1.pop();
        }
        //得到“队列”开头的元素
        int val=sck2.top();
        // 清空sck2，元素放入到sck1
        while(!sck2.empty()){
            sck1.push(sck2.top());
            sck2.pop();
        }
        return val;
    }
    
    bool empty() {
        if(sck1.empty()){
            return true;
        }
        return false;
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



# 

| **LeetCode题目** | **相关题目类型**         | 关键点 | **相关链接**                                                 |
| ---------------- | ------------------------ | ------ | ------------------------------------------------------------ |
| 225              | 用队列实现栈（简单难度） |        | [225. 用队列实现栈 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-stack-using-queues/) |

 **queue 的基本操作有**：
入队，如例：q.push(x); 将x 接到队列的末端。
出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。
访问队首元素，如例：q.front()，即最早被压入队列的元素。
访问队尾元素，如例：q.back()，即最后被压入队列的元素。
判断队列空，如例：q.empty()，当队列空时，返回true。
访问队列中的元素个数，如例：q.size() 

```
class MyStack {
public:
    queue<int> que1;
    queue<int> que2; // 辅助队列，用来备份
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** 将元素 x 压入栈顶。 */
    void push(int x) {
        que1.push(x);
    }

    /** 移除并返回栈顶元素。 */
    int pop() {
        int size=que1.size();
        size--;
        // 把que1元素放到que2，但保留最后一个
        while(size--){
            int num=que1.front();
            que1.pop();
            que2.push(num);
        }
        int res=que1.front();
        que1.pop();
        que1=que2;
        // 清空que2
        while(!que2.empty()){
            que2.pop();
        }
        return res;
    }

    /** 返回栈顶元素。 */
    int top() {
        return que1.back();
    }

    /** 如果栈是空的，返回 true ；否则，返回 false */
    bool empty() {
        return que1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

